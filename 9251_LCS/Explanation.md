# 9251, LCS(Logest Common Subsequence)
## 두 문자열이 주어졌을 때, 두 문자열의 공통된 문자들로 이뤄진 부분수열 중 가장 긴 것을 찾는 문제
* ## Dynamic Programming(동적 계획법) 문제 중 유명한 문제이다. 처음엔 구현 방법들을 검색해 여러 블로그의 글들을 봤지만 명확하게 설명된 글은 없었다. 그래서 기존에 알고 있던 DP의 패턴을 같이 생각하면서 직접 메모장에 쓰며 이해하기 위해 노력했다. 이해했던 과정은 다음과 같다.
    ## 1. 첫번째의 문자열 중 i 번째의 문자를 for문을 돌며 두번째 문자열의 각 문자들과 모두 비교하고, 같다면 2차원 배열로 선언된 메모리제이션 테이블(dp 테이블)의 [i - 1][j - 1] 번째 값에서 +1 한 값을 dp 테이블에 저장하고, 다르다면 Max([i - 1][j], [i][j - 1])번째 값을 dp 테이블에 저장하는데, 이유가 뭘까 라고 생각했다.
    ## 2. 이를 이해하기 위해 예를 들어 CA, AC 라는 두개의 문자열이 있다고 생각해 보았다. 이 두 문자열들의 부분수열은 각각 [C], [A], [CA] 와 [A], [C], [AC] 이다. 일단 첫번째로 첫번째 문자열[0] 번째와 두번째 문자열[0] 번째를 비교해 보면, [C]와 [A]는 서로 다른 문자이다. 만약 현재 첫번째 문자열이 CA가 아닌 C 라는 단일 문자이고, 두번째 문자열도 AC가 아닌 A 라고 본다면, 현재 LCS의 길이는 0(두 문자열(C와 A)에서 중복(공통)되는 문자가 없으므로)이 된다.
    * ## 현재 dp 테이블: dp[1][1] = 0 (편의상 0번째들은 전부 0으로 채우고(dp[i][0]들과 dp[0][i]들) 시작한다. 왜냐하면 보통 dp 문제들이 하나 혹은 두개 정도의 점화식을 가지게 되는데, 이때 이전 dp 테이블의 저장된 값을 쓰는 경우가 많아(dp[i] = dp[i - 1]처럼) 따로 처리를 해주기보다 그냥 편하게 1번째 부터 써서 인덱스 문제를 해결한다. 물론 어떤 문제들은 첫번째 혹은 첫번째 부터 두 ~ 세번째 정도의 값까지 임의로 따로 설정해주는 문제도 있다.)
    ## 3. 그 후 첫번째 문자열의 i번째와 두번째 문자열의 문자들을 전부 비교한다고 했으므로 [C]와 [C]를 비교한다. 두 문자열은 서로 같은데, 이전과는 조금 다르게 첫번째 문자열은 동일하게 C(현재 앞순서들에 문자가 없으므로(첫번째 문자이므로)), 두번째 문자열은 AC 라고 해보겠다. 왜냐하면 두 문자열 C와 C는 서로 같다고 했는데, 그렇다면 현재 값을 따로 또 계산하기보다 그냥 이전에 계산된 값에 +1을 하면 되는 것 아닐까? 라고 생각해볼 수 있기 때문이다. 더 자세히 설명하면, 현재 구해야 하는것은 가장 큰 LCS 길이이다. 그리고 두개의 문자열이 CA와 AC가 아닌 C와 AC 라고 보고, C와 A, C와 C를 비교한다면, 결국 C와 A를 비교한 후(A가 첫번째 문자이므로) 그 다음 순서로 C를(두번째 문자열의 C) 비교하게 된다. 그러면 두번째 문자열의 A까지 비교한 값이 현재까지의 최대 LCS 길이가 되는 것이다. 그런데 C와 C를 비교해보니 서로 같다면, 이전까지의 최대 LCS값에서 1을 더 증가시킬 수 있는 명분이 된다.(C는 공통되므로 LCS에 들어갈 수 있음) 그러므로 A까지 계산되었던 값 0 에서 1을 더해 1 이라는 값을 dp[1][2] 번째에 저장하게 된다.
    ## 4. 그 후 C와 두번째 문자열의 문자들을 전부 비교하였으므로 i + 1 을 해 첫번째 문자열의 A로 넘어간다. A는 또다시 A, C 와 비교를 하게 되는데, 일단 첫번째로 A와 A를 비교해 본다. 두 문자열은 같으므로 일단 1을 저장한다. 이때, 첫번째 문자열은 이전의 논리처럼 CA 로 볼 수 있다. 만약 CA와 A를 비교한다면 LCS 길이는 1이 된다.
    ## 5. 그다음 두번째 문자 C를 i번째 문자 A와 비교해본다. 두 문자는 다른데, 그렇다면 첫번째 문자열이 [CA]일때의 최대 LCS 길이, [A]를 제외하고 [C]일때의 LCS 길이 두 경우 중 더 큰 값을 저장할 수 있을 것이다. [C]와 [A]는 다른 문자이므로 LCS에 포함될 수 없어서 1은 더할 수 없다. 좀 더 자세히 설명하면, 최대한 긴 문자열이 LCS가 되야하므로 일단 [CA]일때의 현재 최대 LCS 길이를 가져올 수도 있다. 현재 i번째 문자는 [A]인데, 사실 이전에 [C]가 있었으므로 현재 문자열은 [CA]라고 볼수도 있다. 그런데 경우에 따라 이전 [C]만 있었을 때의 값이 더 클 수도 있다. 이 부분은 문자열이 길수록 더 가능성이 높아질 것이다. [ABCD]가 있을때, [D]라는 문자를 비교하고 있다면 [ABC]값이 더 클수도 있지만, [AB]값이 더 클수도 있는 것이다. 그렇기에 현재 두번째 문자열 중 비교하고 있는 문자 [C]와 [A] 이전의 문자 [C] 까지 비교한 값과 [CA]와 두번째 문자열 중 비교하고 있는 문자의 바로 앞에 있던 [A]까지 비교한 값 중 더 큰 값을 골라 저장해야 할 것이다. 이는 Max(dp[i - 1][j], [i][j - 1]) 이 된다.
    ## 6. 근데 만약 비교하는 값이 둘다 [A] 이고, i = 2 라면 [i][j - 1] 값을 가져올 수는 없을 것이다. [CA]와 [CA]가 있다면 현재 비교하고 있는 값은 [A]와 [A]인데, 이때 LCS를 구하려면 이전 문자 [C]를 [A]에 붙여 [CA]를 만들 수 있을 것이다. 그러면 길이를 구할 때 [C]까지의 길이를 가져와서 +1을 해줘야 할텐데, 만약 [i][j - 1] 값이 무조건 이전까지 구해진 값이라면 그걸 써도 된다. 하지만 LCS는 비교하는 두 문자가 같을수도, 다를수도 있다. 만약 다르다면 [i][j - 1] 값은 [i - 1][j - 1]([i][j - 1]일때의 문자까지의 바로 이전값)이거나 [i][j - 2]([i][j - 1]일때의 문자의 이전 문자의 값)일 것이다. 그렇다면 [i][j - 1]값은 현재 [i][j]값의 바로 이전값이라는 보장을 세울수가 없다. 그래서, [CA]와 [CA]가 있고 [A]와 [A]를 비교하고 있다면, [A]에 바로 이전 문자 [C]를 더해 [CA]라는 문자열을 만들수도 있을 것이다. LCS 길이로 보면, [C]까지 구해진 값에 +1을 해야한다는 뜻이다. [C]와 [C]를 비교한 값은 i - 1, j - 1 이다.([CA]이고 i가 2라면 [C]는 i - 1, 똑같이 두번째 문자열도 j - 1) 그렇기에 두 문자가 같다면 dp[i][j] = dp[i - 1][j - 1] + 1 값인 것이다.
