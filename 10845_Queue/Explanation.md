# 10845, 큐
## 입력으로 주어지는 각 명령들을 처리하는 문제
* ## 명령은 총 6가지이고, 다음과 같다
    * ## push X: 정수 X를 큐에 넣는 연산
    * ## pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력. 단 큐에 들어있는 정수가 없으면 -1을 출력
    * ## size: 큐에 들어있는 정수의 개수를 출력
    * ## empty: 큐가 비어있으면 1, 아니면 0을 출력
    * ## front: 큐의 가장 앞에 있는 정수를 출력, 단 큐에 들어있는 정수가 없으면 -1을 출력
    * ## back: 큐의 가장 뒤에 있는 정수를 출력, 단 큐에 들어있는 정수가 없으면 -1을 출력
* ## 이 문제는 기본적인 큐 문제를 구현하는 문제였는데, 항상 c로 최대한 모든 걸 직접 구현하다보니 큐를 구현하는건 어렵지 않았다.<br>그래서 문제를 풀며 고민한건 딱 2가지 였는데 다음과 같다.
    * ## 1. 큐를 구현하기 위해 단방향 연결 리스트를 사용하기로 했으므로 Pop 프로시저에서 현재 head가 참조하는 메모리를 해제하고 head의 next를 다시 head가 참조해야 하는데,<br>head를 먼저 free()로 해제 후 다시 next를 참조하게 할 수 있을까?</br>
        * ### 조금만 생각해보니 답이 나왔다. 메모리를 해제할 때, head가 참조하고 있는 메모리를 해제하는 것이지 head 포인터 변수 자체가 해제되는 것은 아니기에 free(head) 이후 head = (미리 변수에 저장한 head의 next) 로 head에 새 주소를 참조시켜도 상관없었다.
    * ## 2. 모든 명령을 함수로 만든 후, 이를 실행하게 할 때 문자열로 명령을 받아 해당하는 함수를 실행하게 해야되는데 어떻게 구현할까?
        * ### 처음엔 if문 등을 이용해 명령을 차례로 비교하고 해당하는 명령이면 해당하는 함수를 실행하게 하는 하드코딩을 생각했었다.
        * ### 하지만 만약 명령의 수가 많아진다면 계속 코드를 고치는 것도 힘들고, 가독성도 떨어지기 때문에 함수 포인터 배열에 함수들을 넣고, 명령 문자열 배열에 모든 명령어들을 넣어 for문을 통해 실행하는 것을 생각해보았다.
        * ### 이 방법은 가독성, 확장성 모두 괜찮았지만 Push() 함수는 int형 매개변수 하나를 받고, 유일하게 반환값이 없는 void 형식이라서 모두 함수 포인터 배열에 넣기에는 조금 애매했다.
        * ### 이 문제를 해결하기 위해 반환값이 있는 함수 포인터 배열, 반환값이 없는 함수 포인터 배열 두개로 나눌까 생각도 했지만 다시 생각해보니 현재 계획에서 더 확장될 일은 없고, 그렇다면 두개의 배열로 나누는 것은 과하다고 생각됐다.
        * ### 결국 최종적으로는 Push() 함수를 제외한 나머지 함수들을 함수 포인터 배열에 넣고, 동일하게 push 명령을 제외한 나머지 명령들을 문자열 배열에 넣어 for문을 돌려 검사 및 실행하도록 하였다.
        * ### 또 push 명령은 따로 처리하여 현재 명령이 push 라면 명시적으로 Push() 함수를 실행하게 하였다.